name: ç‰ˆæœ¬æ›´æ–°ç›‘æ§ - GitHub Releases

on:
  workflow_dispatch:
    inputs:
      repos:
        description: "è¦ç›‘æ§çš„ä»“åº“åˆ—è¡¨ï¼ˆé€—å·æˆ–æ¢è¡Œåˆ†éš”çš„ owner/repoï¼‰ã€‚ç•™ç©ºåˆ™ä½¿ç”¨ RELEASE_WATCH_REPOSã€‚"
        required: false
        default: ""

concurrency:
  group: watch-github-releases
  cancel-in-progress: false

permissions:
  contents: read
  issues: write

jobs:
  watch:
    name: æ£€æŸ¥æœ€æ–° Release
    runs-on: ubuntu-latest
    steps:
      - name: æ£€æŸ¥å¹¶æ›´æ–° Issue
        uses: actions/github-script@v8
        env:
          RELEASE_WATCH_REPOS: ${{ vars.RELEASE_WATCH_REPOS }}
        with:
          script: |
            const issueTitle = "ç‰ˆæœ¬æ›´æ–°ç›‘æ§";
            const inputReposRaw = (core.getInput("repos") || "").trim();
            const envReposRaw = (process.env.RELEASE_WATCH_REPOS || "").trim();
            const raw = inputReposRaw.length > 0 ? inputReposRaw : envReposRaw;

            if (!raw) {
              core.setFailed(
                "æœªé…ç½®ç›‘æ§ä»“åº“åˆ—è¡¨ï¼šè¯·åœ¨ workflow_dispatch è¾“å…¥ reposï¼Œæˆ–åœ¨ä»“åº“ Variables ä¸­è®¾ç½® RELEASE_WATCH_REPOS"
              );
              return;
            }

            const repos = Array.from(
              new Set(
                raw
                  .split(/[\n,]+/g)
                  .map((s) => s.trim())
                  .filter((s) => s.length > 0)
              )
            );

            const invalid = repos.filter((r) => !/^[^/]+\/[^/]+$/.test(r));
            if (invalid.length > 0) {
              core.setFailed(`ä»“åº“æ ¼å¼æ— æ•ˆï¼ˆéœ€ä¸º owner/repoï¼‰ï¼š${invalid.join(", ")}`);
              return;
            }

            const { owner, repo } = context.repo;

            const listOpenIssues = async () =>
              github.paginate(github.rest.issues.listForRepo, {
                owner,
                repo,
                state: "open",
                per_page: 100,
              });

            const ensureIssue = async () => {
              const issues = await listOpenIssues();
              const existing = issues.find((i) => i.title === issueTitle);
              if (existing) return existing;
              const created = await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body: "åˆå§‹åŒ–ä¸­â€¦\n",
              });
              return created.data;
            };

            const stateStart = "<!-- RELEASE_WATCH_STATE_START -->";
            const stateEnd = "<!-- RELEASE_WATCH_STATE_END -->";

            const extractState = (body) => {
              if (!body) return { ok: false, state: {} };
              const start = body.indexOf(stateStart);
              const end = body.indexOf(stateEnd);
              if (start === -1 || end === -1 || end <= start) return { ok: false, state: {} };
              const jsonText = body.slice(start + stateStart.length, end).trim();
              try {
                const parsed = JSON.parse(jsonText || "{}");
                return { ok: true, state: parsed && typeof parsed === "object" ? parsed : {} };
              } catch {
                return { ok: false, state: {} };
              }
            };

            const renderStateBlock = (state) =>
              `${stateStart}\n${JSON.stringify(state, null, 2)}\n${stateEnd}`;

            const getLatestRelease = async (fullName) => {
              const [o, r] = fullName.split("/");

              try {
                const latest = await github.rest.repos.getLatestRelease({ owner: o, repo: r });
                const data = latest.data;
                if (data && !data.draft && !data.prerelease) {
                  return {
                    tag: data.tag_name || "",
                    name: data.name || "",
                    url: data.html_url || "",
                    publishedAt: data.published_at || "",
                  };
                }
              } catch (e) {
                // getLatestRelease åœ¨æ—  release æ—¶å¯èƒ½è¿”å› 404ï¼›å…¶å®ƒé”™è¯¯ä¹Ÿå›é€€
              }

              const list = await github.rest.repos.listReleases({ owner: o, repo: r, per_page: 20 });
              const found = (list.data || []).find((rel) => !rel.draft && !rel.prerelease);
              if (!found) {
                return null;
              }
              return {
                tag: found.tag_name || "",
                name: found.name || "",
                url: found.html_url || "",
                publishedAt: found.published_at || "",
              };
            };

            const issue = await ensureIssue();
            const currentBody = issue.body || "";
            const extracted = extractState(currentBody);
            const state = extracted.state || {};

            const nowRunUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;
            const results = [];
            let hasUpdate = false;
            const errors = [];

            for (const fullName of repos) {
              try {
                const latest = await getLatestRelease(fullName);
                if (!latest) {
                  results.push({
                    repo: fullName,
                    status: "æ—  Release",
                    latestTag: "",
                    latestUrl: "",
                    publishedAt: "",
                  });
                  continue;
                }

                const prev = state[fullName] || {};
                const prevTag = prev.tag || "";
                const changed = latest.tag && latest.tag !== prevTag;

                if (changed) {
                  hasUpdate = true;
                  state[fullName] = {
                    tag: latest.tag,
                    url: latest.url,
                    publishedAt: latest.publishedAt,
                    lastSeenAt: new Date().toISOString(),
                  };
                } else if (!prevTag) {
                  state[fullName] = {
                    tag: latest.tag,
                    url: latest.url,
                    publishedAt: latest.publishedAt,
                    lastSeenAt: new Date().toISOString(),
                  };
                } else {
                  state[fullName] = {
                    ...prev,
                    lastSeenAt: new Date().toISOString(),
                  };
                }

                results.push({
                  repo: fullName,
                  status: changed ? "ğŸ†• æ›´æ–°" : "âœ… æ— å˜åŒ–",
                  latestTag: latest.tag,
                  latestUrl: latest.url,
                  publishedAt: latest.publishedAt,
                });
              } catch (e) {
                errors.push(`${fullName}: ${e && e.message ? e.message : String(e)}`);
                results.push({
                  repo: fullName,
                  status: "âŒ æ£€æŸ¥å¤±è´¥",
                  latestTag: "",
                  latestUrl: "",
                  publishedAt: "",
                });
              }
            }

            const lines = [];
            lines.push("## ç›‘æ§ç»“æœ");
            lines.push("");
            lines.push(`- æ›´æ–°æ—¶é—´: ${new Date().toISOString()}`);
            lines.push(`- æœ¬æ¬¡è¿è¡Œ: ${nowRunUrl}`);
            lines.push("");
            lines.push("| ä»“åº“ | çŠ¶æ€ | æœ€æ–°ç‰ˆæœ¬ | å‘å¸ƒæ—¶é—´ |");
            lines.push("|---|---|---|---|");
            for (const r of results) {
              const tag = r.latestTag ? `\`${r.latestTag}\`` : "-";
              const link = r.latestUrl ? `[${tag}](${r.latestUrl})` : tag;
              const publishedAt = r.publishedAt ? `\`${r.publishedAt}\`` : "-";
              lines.push(`| \`${r.repo}\` | ${r.status} | ${link} | ${publishedAt} |`);
            }

            if (errors.length > 0) {
              lines.push("");
              lines.push("## é”™è¯¯");
              for (const e of errors) {
                lines.push(`- ${e}`);
              }
            }

            if (!extracted.ok) {
              lines.push("");
              lines.push("> æ³¨æ„ï¼šæ£€æµ‹åˆ°çŠ¶æ€åŒºå—ç¼ºå¤±æˆ–æŸåï¼Œå·²è‡ªåŠ¨é‡å»ºçŠ¶æ€ã€‚");
            }

            lines.push("");
            lines.push("## çŠ¶æ€ï¼ˆè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘ï¼‰");
            lines.push("");
            lines.push(renderStateBlock(state));

            const newBody = lines.join("\n");
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: issue.number,
              body: newBody,
            });

            core.summary
              .addHeading("ç‰ˆæœ¬ç›‘æ§ç»“æœ", 3)
              .addRaw(`- Issue: ${context.serverUrl}/${owner}/${repo}/issues/${issue.number}\n`)
              .addRaw(`- æœ¬æ¬¡è¿è¡Œ: ${nowRunUrl}\n`)
              .addRaw(`- æ˜¯å¦æœ‰æ›´æ–°: ${hasUpdate ? "æ˜¯" : "å¦"}\n`)
              .write();

